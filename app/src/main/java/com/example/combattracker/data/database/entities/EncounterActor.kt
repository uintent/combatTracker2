// File: EncounterActor.kt
package com.example.combattracker.data.database.entities

import androidx.room.*

/**
 * EncounterActor Entity - Represents an instance of an actor within a specific encounter
 *
 * Purpose:
 * - Links actors from the library to specific encounters
 * - Tracks encounter-specific state (initiative, turn status, position)
 * - Supports multiple instances of the same actor (e.g., "Goblin 1", "Goblin 2")
 *
 * Requirements Reference:
 * From section 3.1.4: Multiple Actor Instances
 * - Unique numbers appended to names
 * - Counter persists throughout encounter
 * From section 3.3.3: Initiative System
 * - Initiative values with decimal support for NPCs
 * - Turn tracking and ordering
 */
@Entity(
    tableName = "encounter_actors",
    // Define foreign key relationships
    foreignKeys = [
        ForeignKey(
            entity = Encounter::class,
            parentColumns = ["id"],
            childColumns = ["encounterId"],
            onDelete = ForeignKey.CASCADE // Delete actors when encounter is deleted
        ),
        ForeignKey(
            entity = Actor::class,
            parentColumns = ["id"],
            childColumns = ["baseActorId"],
            onDelete = ForeignKey.RESTRICT // Prevent deleting actors that are in encounters
        )
    ],
    // Create indices for better query performance
    indices = [
        Index(value = ["encounterId"]), // Fast lookup by encounter
        Index(value = ["baseActorId"]), // Fast lookup by base actor
        Index(value = ["encounterId", "displayName"], unique = true) // Ensure unique names per encounter
    ]
)
data class EncounterActor(
    /**
     * Unique identifier for this encounter actor instance
     * Auto-generated by Room
     */
    @PrimaryKey(autoGenerate = true)
    val id: Long = 0,

    /**
     * Reference to the parent encounter
     * Links to Encounter.id
     */
    val encounterId: Long,

    /**
     * Reference to the base actor template
     * Links to Actor.id
     * Used to fetch portrait, category, etc.
     */
    val baseActorId: Long,

    /**
     * Display name for this instance
     * Includes instance number if multiple (e.g., "Goblin 2")
     * Unique within the encounter
     */
    val displayName: String,

    /**
     * Instance number for multiple actors
     * 0 = single instance (no number shown)
     * 1+ = multiple instances (number appended to name)
     * Used to maintain counter even after removals
     */
    val instanceNumber: Int = 0,

    /**
     * Current initiative value
     * Null = not yet rolled
     * Double to support decimal tie-breaking for NPCs
     * Integer values for players (e.g., 15.0)
     * Decimal values for NPCs (e.g., 15.1234)
     */
    val initiative: Double? = null,

    /**
     * Initiative modifier at time of adding to encounter
     * Cached from base actor to handle changes
     * Preserves the modifier used when encounter was saved
     */
    val initiativeModifier: Int,

    /**
     * Whether this actor has taken their turn in current round
     * Reset to false at start of each round
     * Set to true when turn is completed
     */
    val hasTakenTurn: Boolean = false,

    /**
     * Manual sort order for resolving player ties
     * Only used when multiple players have same initiative
     * Lower values appear first (left) in tracker
     * 0 = default position
     */
    val tieBreakOrder: Int = 0,

    /**
     * Position in the encounter for stable sorting
     * Used when actors haven't rolled initiative yet
     * Maintains the order they were added
     */
    val addedOrder: Int = 0,

    /**
     * Whether this actor is temporarily hidden
     * For future feature: hiding actors from players
     */
    val isHidden: Boolean = false
) {
    /**
     * Check if initiative has been rolled
     *
     * @return True if initiative is not null
     */
    fun hasInitiative(): Boolean = initiative != null

    /**
     * Check if this is a player character based on initiative
     * Players have integer initiative values
     *
     * @return True if initiative is an integer value
     */
    fun isPlayerCharacter(): Boolean {
        return initiative?.let {
            it == it.toInt().toDouble()
        } ?: false
    }

    /**
     * Get the base name without instance number
     * "Goblin 2" -> "Goblin"
     *
     * @return Base name without number suffix
     */
    fun getBaseName(): String {
        return if (instanceNumber > 0 && displayName.matches(Regex(".*\\s\\d+$"))) {
            displayName.substringBeforeLast(" ")
        } else {
            displayName
        }
    }

    /**
     * Create a copy with rolled initiative
     *
     * @param rolledValue The new initiative value
     * @return Updated actor with initiative
     */
    fun withInitiative(rolledValue: Double): EncounterActor {
        return this.copy(initiative = rolledValue)
    }

    /**
     * Create a copy after taking turn
     *
     * @return Updated actor marked as having taken turn
     */
    fun afterTurn(): EncounterActor {
        return this.copy(hasTakenTurn = true)
    }

    /**
     * Create a copy for new round
     *
     * @return Updated actor with turn status reset
     */
    fun newRound(): EncounterActor {
        return this.copy(hasTakenTurn = false)
    }

    /**
     * Create a copy with updated tie-break order
     *
     * @param newOrder The new position for tie-breaking
     * @return Updated actor with new order
     */
    fun withTieBreakOrder(newOrder: Int): EncounterActor {
        return this.copy(tieBreakOrder = newOrder)
    }

    companion object {
        /**
         * Create a new encounter actor from a base actor
         *
         * @param encounter The parent encounter
         * @param baseActor The actor template
         * @param instanceNumber The instance number (0 for single)
         * @param addedOrder Order in which actor was added
         * @return New EncounterActor instance
         */
        fun fromActor(
            encounter: Encounter,
            baseActor: Actor,
            instanceNumber: Int = 0,
            addedOrder: Int = 0
        ): EncounterActor {
            // Generate display name with instance number if needed
            val displayName = if (instanceNumber > 0) {
                "${baseActor.name} $instanceNumber"
            } else {
                baseActor.name
            }

            return EncounterActor(
                encounterId = encounter.id,
                baseActorId = baseActor.id,
                displayName = displayName,
                instanceNumber = instanceNumber,
                initiativeModifier = baseActor.initiativeModifier,
                addedOrder = addedOrder
            )
        }

        /**
         * Sort comparator for encounter actors
         *
         * Sort order:
         * 1. Actors with initiative before those without
         * 2. Higher initiative first
         * 3. Lower tie-break order for same initiative
         * 4. Added order for actors without initiative
         */
        val combatComparator = Comparator<EncounterActor> { a, b ->
            when {
                // Both have no initiative - sort by added order
                a.initiative == null && b.initiative == null -> {
                    a.addedOrder.compareTo(b.addedOrder)
                }
                // One has no initiative - it goes last
                a.initiative == null -> 1
                b.initiative == null -> -1
                // Different initiatives - higher first
                a.initiative != b.initiative -> {
                    b.initiative.compareTo(a.initiative)
                }
                // Same initiative - use tie-break order
                else -> {
                    a.tieBreakOrder.compareTo(b.tieBreakOrder)
                }
            }
        }
    }
}