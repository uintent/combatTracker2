// File: ActorCondition.kt
package com.example.combattracker.data.database.entities

import androidx.room.*

/**
 * ActorCondition Entity - Represents an active condition on a specific actor in combat
 *
 * Purpose:
 * - Tracks which conditions are currently affecting which actors
 * - Manages duration (in turns) or permanent status
 * - Links conditions to specific encounter actors
 *
 * Requirements Reference:
 * From section 3.4.2: Context Menu Sections - Conditions Section
 * - Each condition with: Toggle (on/off), Count field, Permanent checkbox
 * - If "Permanent" is checked, the Count field is greyed out
 * From section 3.5.3: Condition Management
 * - Duration Tracking: Optional countdown per application
 * - Automatic Removal: Conditions automatically removed when duration expires
 */
@Entity(
    tableName = "actor_conditions",
    // Define foreign key relationships
    foreignKeys = [
        ForeignKey(
            entity = EncounterActor::class,
            parentColumns = ["id"],
            childColumns = ["encounterActorId"],
            onDelete = ForeignKey.CASCADE // Remove conditions when actor is removed
        ),
        ForeignKey(
            entity = Condition::class,
            parentColumns = ["id"],
            childColumns = ["conditionId"],
            onDelete = ForeignKey.RESTRICT // Prevent deleting conditions that are in use
        )
    ],
    // Ensure unique condition per actor (can't have same condition twice)
    indices = [
        Index(value = ["encounterActorId", "conditionId"], unique = true),
        Index(value = ["encounterActorId"]), // Fast lookup by actor
        Index(value = ["conditionId"]) // Fast lookup by condition
    ]
)
data class ActorCondition(
    /**
     * Unique identifier for this condition application
     * Auto-generated by Room
     */
    @PrimaryKey(autoGenerate = true)
    val id: Long = 0,

    /**
     * The actor this condition is applied to
     * References EncounterActor.id
     */
    val encounterActorId: Long,

    /**
     * The condition being applied
     * References Condition.id (1-15)
     */
    val conditionId: Long,

    /**
     * Whether this condition is permanent
     * If true, duration is ignored
     * If false, duration must be > 0
     */
    val isPermanent: Boolean = false,

    /**
     * Duration in actor turns
     * Only used if isPermanent is false
     * Decrements when the affected actor ends their turn
     * Condition is removed when this reaches 0
     *
     * Note: Current round counts as one round for countdown
     */
    val remainingDuration: Int? = null,

    /**
     * The round when this condition was applied
     * Used for tracking and debugging
     */
    val appliedAtRound: Int = 1,

    /**
     * Timestamp when condition was applied
     * For sorting and debugging
     */
    val appliedAt: Long = System.currentTimeMillis(),

    /**
     * Optional notes about the condition
     * For future use - source of condition, special rules, etc.
     */
    val notes: String? = null
) {
    /**
     * Check if this condition has expired
     *
     * @return True if duration-based and duration is 0 or less
     */
    fun isExpired(): Boolean {
        return !isPermanent && (remainingDuration ?: 0) <= 0
    }

    /**
     * Check if this condition is currently active
     *
     * @return True if permanent or has remaining duration
     */
    fun isActive(): Boolean {
        return isPermanent || (remainingDuration ?: 0) > 0
    }

    /**
     * Get display text for duration
     *
     * @return "Permanent" or number of turns remaining
     */
    fun getDurationDisplay(): String {
        return when {
            isPermanent -> "Permanent"
            remainingDuration == null -> "Invalid"
            remainingDuration == 1 -> "1 turn"
            else -> "$remainingDuration turns"
        }
    }

    /**
     * Decrement the duration after actor's turn
     *
     * @return Updated condition with reduced duration, or null if expired
     */
    fun afterActorTurn(): ActorCondition? {
        return when {
            isPermanent -> this // No change for permanent
            remainingDuration == null -> null // Invalid state
            remainingDuration <= 1 -> null // Expired, should be removed
            else -> this.copy(remainingDuration = remainingDuration - 1)
        }
    }

    /**
     * Validate the condition data
     *
     * @return True if valid state
     */
    fun isValid(): Boolean {
        return when {
            isPermanent -> true // Permanent is always valid
            remainingDuration == null -> false // Non-permanent needs duration
            remainingDuration <= 0 -> false // Duration must be positive
            else -> true
        }
    }

    companion object {
        /**
         * Create a new permanent condition
         *
         * @param actorId The encounter actor ID
         * @param conditionId The condition ID (1-15)
         * @param currentRound The current combat round
         * @return New permanent condition
         */
        fun createPermanent(
            actorId: Long,
            conditionId: Long,
            currentRound: Int = 1
        ): ActorCondition {
            return ActorCondition(
                encounterActorId = actorId,
                conditionId = conditionId,
                isPermanent = true,
                remainingDuration = null,
                appliedAtRound = currentRound
            )
        }

        /**
         * Create a new temporary condition
         *
         * @param actorId The encounter actor ID
         * @param conditionId The condition ID (1-15)
         * @param duration Duration in turns (must be > 0)
         * @param currentRound The current combat round
         * @return New temporary condition
         */
        fun createTemporary(
            actorId: Long,
            conditionId: Long,
            duration: Int,
            currentRound: Int = 1
        ): ActorCondition {
            require(duration > 0) { "Duration must be positive" }

            return ActorCondition(
                encounterActorId = actorId,
                conditionId = conditionId,
                isPermanent = false,
                remainingDuration = duration,
                appliedAtRound = currentRound
            )
        }

        /**
         * Create a condition from user input
         * Handles the validation mentioned in requirements
         *
         * @param actorId The encounter actor ID
         * @param conditionId The condition ID
         * @param isPermanent Whether permanent is checked
         * @param duration User-entered duration
         * @param currentRound Current round number
         * @return New condition or error
         */
        fun createFromInput(
            actorId: Long,
            conditionId: Long,
            isPermanent: Boolean,
            duration: String?,
            currentRound: Int
        ): Result<ActorCondition> {
            return try {
                if (isPermanent) {
                    Result.success(createPermanent(actorId, conditionId, currentRound))
                } else {
                    val durationInt = duration?.toIntOrNull()
                    if (durationInt == null || durationInt <= 0) {
                        Result.failure(IllegalArgumentException(
                            "Please specify a duration or select 'Permanent'"
                        ))
                    } else {
                        Result.success(createTemporary(actorId, conditionId, durationInt, currentRound))
                    }
                }
            } catch (e: Exception) {
                Result.failure(e)
            }
        }
    }
}

/**
 * Data class for condition with full details
 * Used in UI to avoid multiple database queries
 */
data class ActorConditionWithDetails(
    @Embedded val actorCondition: ActorCondition,
    @Relation(
        parentColumn = "conditionId",
        entityColumn = "id"
    )
    val condition: Condition
)